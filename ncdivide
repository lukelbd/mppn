#!/usr/bin/env bash
usage="ncdivide [-fsh] [-d=DIMNAME] [-p=NP] [-n=NF] INPUT"
doc="This script divides a NetCDF file along an arbitrary dimension using
parallelized 'ncks' hyperslab selection.

Usage

  $usage

Optional arguments

  -h   Print this message.
  -f   If passed and dimension is a 'record' dimension, it is changed to fixed length.
  -s   If passed, silent mode is enabled.
  -d=* The dimension name along which we split the file. Defaults to 'lat'.
  -n=* The number of file pieces to generate. Defaults to '8'.
  -p=* The maximum number of parallel processes. This defaults to the -n
       argument but can also be smaller.
"
# Get arguments
# debug='-D 2'
debug=''
fixrec=false
dimname=lat # can also split along time dimension?
nsplit=8
silent=false
dir=${0%/*}
source $dir/header.sh
while [ $# -ne 0 ]; do
  case $1 in
    -h) echo "$doc" >&2 && exit 0 ;;
    -d=*) dimname=${1#*=} ;;
    -n=*) nsplit=${1#*=} ;;
    -p=*) pmax=${1#*=} ;;
    -f) fixrec=true ;; # fix record dimension?
    -s) silent=true ;;
    -*) raise "Unknown flag ${1}." ;;
    *)  [ -n "$input" ] && raise "Got multiple files."; input="$1" ;;
  esac
  shift
done
[ -z "$pmax" ] && pmax=$nsplit # same as number of files
[ -n "$input" ] || raise "Must pass input filename."
[[ "$input" =~ .nc$ ]] || raise "File does not end in '.nc' extension."
which ncks &>/dev/null || raise "ncks not found, ncdivide requires the NetCDF Operators (NCO) tools."

# Get dimension size by parsing ncks
# Could also parse ncdump, but this script requires NCO already so why not
# See: http://nco.sourceforge.net/nco.html#ncdmnsz
ndim=$(ncks --trd -m -M "$input" | grep -E -i ": ${dimname}, size =" | cut -f 7 -d ' ' | uniq | xargs)
[ -n "$ndim" ] || raise "Dimension ${dimname} not found in filename ${input}."
[[ $ndim =~ ^[0-9]+$ ]] || raise "Got invalid size ${ndim} for dimension ${dimname}."
[ $((ndim % nsplit)) -eq 0 ] || raise "Incompatible dimension size ${ndim} for ${nsplit} splits."

# Optionally fix the record dimension
if $fixrec; then
  ncdump -h "$input" | grep 'UNLIMITED' | grep $dimname &>/dev/null \
    && unlimited=true || unlimited=false
  $unlimited && flag="--fix_rec_dmn $dimname" # required for mppnccombine
fi

# Split up the file and add attributes used by mppnccombine
# WARNING: The attributes must be long type, not short
# WARNING: We employ various flags to optimize performance; use hdr_pad so the
# ncatted do not cause re-reading entire file due to having to shift
# contents down, no_tmp_fl to prevent extra writing, and bfr_sz which mysteriously
# improves performance by quite a lot. Current config seems to be the best we can do.
i=1
for ni in $(seq 1 $nsplit); do
  # Select file chunk and add attributes
  ofile=${input%.nc}.$(printf "%04d" $((ni-1))).nc
  d1=$(((ni - 1) * ndim / nsplit))  # e.g. nsplit=10, ndim=200, goes 0, 20, 40, 60
  d2=$((ni * ndim / nsplit - 1))  # e.g. nsplit=10, ndim=200, goes 19, 39, 59
  {
    ncks -O -h $debug --bfr_sz 2000000 --no_tmp_fl --hdr_pad 1000 --no_abc $flag \
      -d $dimname,$d1,$d2 "$input" "$ofile" >&2
    ncatted -O -h -a NumFilesInSet,global,o,l,"$nsplit" "$ofile"
    ncatted -O -h -a domain_decomposition,$dimname,o,l,"1,$ndim,$((d1 + 1)),$((d2 + 1))" "$ofile"
  } &

  # Store process ids and output files
  pids+=($!)
  ofiles+=("$ofile")
  if [ $i -eq $pmax ]; then
    i=1
    pwait ncks "${pids[@]}"
    unset pids
  else
    i=$((i + 1))
  fi
done
pwait ncks "${pids[@]}"
$silent || echo "${ofiles[@]}"
exit 0
