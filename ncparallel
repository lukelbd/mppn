#!/usr/bin/env bash
################################################################################
# The driver script
# Usage: ./ncparallel 'command' input output
################################################################################
# Get arguments
remove=false
while [ $# -ne 0 ]; do
  case "$1" in
    -[nd]=*) flags+="$1 "
    -r) remove=true ;;
  esac
done
if [ ${#args[@]} -ne 3 ]; then
  echo "Error: Usage is ncparallel 'command' 'input.nc' 'output.nc', where command is any command that accepts an input file and saves data to an output file."
  exit 1
fi
cmd="$1"
input="$2"
output="$3"
# Divide into smaller files and collect names in a bash array
# Format will be input.0000.nc, input.0001.nc, etc.
dir=${0%/*}
inputs=($($dir/ncdivide -d=lat -n=8 "$input"))
[ $? -ne 0 ] && echo "Error: ncdivide failed." && exit 1

# Generate background processes for each file, for example a python script
# that creates a new NetCDF file from some input NetCDF file.
# WARNING: Make sure that your command preserves the 'domain_decomposition' dimension
# attribute and 'NumFilesInSet' global attribute on the output NetCDF file!
for file in "${inputs[@]}"; do
  output="output.${file#*.}" # e.g. if 'file' is input.0000.nc, becomes output.0000.nc
  $cmd "$file" "$output" & # trailing ampersand sends process to background
  outputs+=("$output") # store output files in a bash array
  pids+=($!) # store process IDs in another bash array
done

# Wait for background processes to finish, and make sure they were all successful
for pid in ${pids[@]}; do
  wait $pid
  if [ $? -ne 0 ]; then
    echo "Error: One of the processes failed."
    exit 1
  fi
done

# Finally combine, and remove the temporary files
# generated for parallel processing
$dir/nccombine -r output.nc "${outputs[@]}"
[ $? -ne 0 ] && echo "Error: nccombine failed." && exit 1
if $remove; then
  rm "${outputs[@]}" "${inputs[@]}"
fi
