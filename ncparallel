#!/usr/bin/env bash
# The driver script
usage="ncparallel [OPTIONS...] [-d=DIMNAME] [-p=NP] [-n=NF] COMMAND INPUT OUTPUT"
doc="This script splits up an input NetCDF file into chunks, runs a script
on some or all of those chunks in parallel, and merges the results into
an output NetCDF file.

Usage

  $usage

Positional arguments

  COMMAND  A command-line command, e.g. './myscript.sh' or a quoted
           string like 'python file.py'.
  INPUT    The input NetCDF file name.
  OUTPUT   The final output NetCDF file name.

Optional arguments

  -h   Print this message.
  -f   If passed and dimension is a 'record' (i.e. unlimited) dimension, it is changed to fixed length.
  -s   If passed, silent mode is enabled.
  -k   If passed, temporary files are not deleted.
  -r   If passed, order of INPUT and OUTPUT is reversed.
  -d=* The dimension name along which we split the file. Defaults to 'lat'.
  -n=* The number of file pieces to generate. Defaults to '8'.
  -p=* The maximum number of parallel processes. This defaults to the -n
       argument but can also be smaller.
"
# Get arguments
# TODO: Support for nsplit=1, just run the command!
keep=false
reverse=false
dname=lat # can also split along time dimension?
nsplit=8
silent=false
dir=${0%/*}
source $dir/header.sh
while [ $# -ne 0 ]; do
  case "$1" in
    -h) echo "$doc" >&2 && exit 0 ;;
    -n=*) nsplit="${1#*=}" ;;
    -d=*) dname="${1#*=}" ;;
    -p=*) pmax="${1#*=}" ;;
    -f) flags="-f" ;;
    -k) keep=true ;;
    -s) silent=true ;;
    -r) reverse=true ;;
    -*) raise "Unknown argument ${1}." ;;
    *) args+=("$1") ;;
  esac
  shift
done
[ -z "$pmax" ] && pmax=$nsplit # same as number of files
[ ${#args[@]} -ne 3 ] && raise "Incorrect usage."
# Variables
dir=${0%/*}
cmd="${args[0]}"
if $reverse; then
  input="${args[2]}"
  output="${args[1]}"
else
  input="${args[1]}"
  output="${args[2]}"
fi
[ -r "$input" ] || raise "Input file \"$input\" not found."
# Time format
if $silent; then
  export TIMEFORMAT=$''
else
  export TIMEFORMAT=$'real %3lR user %3lU sys %3lS'
fi

# Divide into smaller files and collect names in a bash array
# Format will be input.0000.nc, input.0001.nc, etc.
# TODO: Divide up to n blocks
$silent || echo "Dividing file: ${input##*/}"
time {
inputs=($($dir/ncdivide -p=$pmax -n=$nsplit -d=$dname $flags "$input"))
[ $? -ne 0 ] && raise "ncdivide failed."
}

# Generate background processes for each file, for example a python script
# that creates a new NetCDF file from some input NetCDF file.
# WARNING: Make sure that your command preserves the 'domain_decomposition' dimension
# attribute and 'NumFilesInSet' global attribute on the output NetCDF file!
i=1
time {
$silent || echo "Running $cmd"
$silent || echo "Input files: ${inputs[@]##*/}"
for ifile in "${inputs[@]}"; do
  # Output name
  prefix="${output%.nc}" # just trim the extension
  suffix="${ifile:${#ifile}-7}" # 0000.nc, 0001.nc, etc.
  ofile="${prefix}.${suffix}"
  # Run command
  if $reverse; then
    $cmd "$ofile" "$ifile" &>/dev/null & # trailing ampersand sends process to background
  else
    $cmd "$ifile" "$ofile" &>/dev/null & # trailing ampersand sends process to background
  fi
  pids+=($!) # store process IDs in another bash array
  outputs+=("$ofile") # store output files in a bash array
  if [ $i -eq $pmax ]; then
    i=1; pwait "$cmd" "${pids[@]}"
    unset pids
  else
    let i+=1
  fi
done
pwait "$cmd" "${pids[@]}"
$silent || echo "Output files: ${outputs[@]##*/}"
}

# Finally combine, and remove the temporary files
# generated for parallel processing
$silent || echo "Combining into file: ${output##*/}"
time {
$dir/nccombine "$output" "${outputs[@]}"
[ $? -ne 0 ] && raise "nccombine failed."
}
! $keep && rm "${outputs[@]}" "${inputs[@]}"
exit 0
